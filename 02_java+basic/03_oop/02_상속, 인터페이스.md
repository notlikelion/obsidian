# 02. 상속, 인터페이스

#java #oop #상속 #inheritance #인터페이스 #interface #추상 #abstract #오버라이딩 #overriding #다형성 #polymorphism #폴리모피즘 #바인딩 #binding #super #슈퍼 #implements #instanceof

---

https://github.com/notlikelion/250804_oop/tree/main/src/step2

## 자주 쓰는 키워드/개념 빠른 참조

- `extends`(클래스 상속) / `implements`(인터페이스 구현)
- `@Override`(컴파일러 검사로 안전한 재정의)
- `super(...)`(부모 생성자 호출), `super.method()`/`super.field`
- 바인딩: 정적(필드, static/final/private/생성자) vs 동적(일반 인스턴스 메서드)
- `instanceof`(런타임 타입 점검) — Java 16+는 패턴 매칭(`instanceof T t`) 지원
- 인터페이스 메서드: `abstract` 기본, Java 8+ `default`/`static`/`private` 허용

---

## 상속 (Inheritance)

#상속 #inheritance #이너리턴스

- 실생활 비유: 설계도를 재사용해 모델을 확장하는 “페이스리프트” 자동차.
- CS 관점: `is-a` 관계에서 코드 재사용과 계층화, 다형성의 기반 제공. 단일 상속만 허용.

```java
class Animal { void eat(){ System.out.println("eat"); } }
class Dog extends Animal { void bark(){ System.out.println("bark"); } }
// 사용
Dog d = new Dog(); d.eat(); d.bark(); // Dog is-a Animal
```

---

## 메서드 오버라이딩 (Method Overriding)

#오버라이딩 #overriding

- 실생활 비유: 기본 메뉴를 우리 집 취향으로 “재설정”.
- 규칙
  1. 시그니처 동일(이름/매개변수/반환형) 2) 접근 범위는 같거나 더 넓게 3) `final`/`static`은 불가

```java
class Animal { void sound(){ System.out.println("..."); } }
class Dog extends Animal {
    @Override void sound(){ System.out.println("bark"); }
}
```

---

## `super` 키워드

#super #슈퍼

- 용도: 부모 생성자 연결 `super(args)`, 오버라이딩된 부모 메서드 `super.method()`, 필드 구분 `super.field`.

```java
class Animal { String name; Animal(String n){ name=n; } }
class Dog extends Animal {
    Dog(String n){ super(n); }      // 1) 부모 생성자 호출
    void print(){ System.out.println(super.name); } // 2) 부모 필드 명시
}
```

---

## 다형성과 바인딩 (Polymorphism & Binding)

#다형성 #polymorphism #폴리모피즘 #바인딩 #binding #바인딩

- 정적 바인딩: 필드, `static`/`final`/`private`/생성자 — “참조 변수의 선언 타입” 기준.
- 동적 바인딩: 일반 인스턴스 메서드 — “실제 객체 타입” 기준 런타임 결정.

```java
class Car {
    int price = 10000;                      // 필드: 정적 바인딩
    void hello(){ System.out.println("Car:"+price); } // 메서드: 동적 바인딩
}
class RacingCar extends Car {
    int price = 50000; // 필드 은닉(섀도잉)
    @Override void hello(){ System.out.println("Racing:"+price); }
}

Car a = new Car();
Car b = new RacingCar();
System.out.println(a.price); // 10000  (정적)
System.out.println(b.price); // 10000  (정적, 선언 타입 Car)
b.hello();                   // Racing:50000 (동적, 실제 객체 RacingCar)
```

---

## 추상 클래스 (Abstract Class)

#추상 #abstract

- 실생활 비유: 제품군의 “뼈대 사양”. 만들 틀은 같지만 세부는 각자 구현.
- CS 관점: 공통 상태/기능 공유 + 일부 행위 강제.

```java
abstract class Worker {
    String name;                   // 공통 상태
    abstract void work();          // 구현 강제(스펙)
    void run(){ System.out.println("뛴다!"); } // 공통 구현
}
class FarmWorker extends Worker { @Override void work(){ System.out.println("농장 좋아!"); } }
class SeaWorker  extends Worker { @Override void work(){ System.out.println("바다 좋아!"); } }

Worker[] ws = { new FarmWorker(), new SeaWorker() };
for (Worker w : ws) { w.work(); } // 다형성 호출
```

---

## 인터페이스 (Interface)

#인터페이스 #interface #인터페이스

- 실생활 비유: 콘센트 규격(모양은 고정, 안의 부품은 제조사마다 자유).
- CS 관점: 다중 구현으로 행위를 조합. 상태 대신 계약 중심. Java 8+ `default`/`static` 지원.

```java
interface Runnable { void run(); default void runToYou(){ System.out.println("무언가..."); } }
interface Talkable { void talk(); }
interface Cute { void doCute(); }

class Dog implements Runnable, Cute {
    public void run(){ System.out.println("개가 뛴다"); }
    public void doCute(){ System.out.println("개는 귀엽다"); }
}
class Human implements Runnable, Talkable {
    public void run(){ System.out.println("사람이 뛴다"); }
    public void talk(){ System.out.println("사람은 말한다"); }
}

Runnable[] arr = { new Dog(), new Human() };
for (Runnable r : arr) {
    r.run(); // 공통 행위
    if (r instanceof Cute c) {      // Java 16+ 패턴 매칭
        c.doCute();
    } else if (r instanceof Talkable t) {
        t.talk();
    }
}
```

---

## `instanceof`와 캐스팅

#instanceof #타입체크 #타입체킹

- 안전 절차: 1) `instanceof`로 확인 → 2) 캐스팅 후 사용. 패턴 매칭 사용 시 캐스팅 축약 가능.

```java
Animal a = new Dog();
if (a instanceof Dog d) { d.bark(); } // 패턴 매칭으로 지역 변수 d 바인딩
```

---

## 캡슐화와 상속의 협업

#캡슐화 #encapsulation #엔캡슐레이션

- 필드는 가급적 `private` + `getter/setter` 제공 → 은닉/무결성 + 안정적 바인딩.
- 자세한 접근 제어는 ‘01. 클래스, 객체, 메서드’ 문서의 [접근 제어자] 섹션을 참고.

```java
class Car2 {
    private final String color = "yellow"; // 직접 접근 X
    String getColor(){ return color; }      // 공개는 메서드로 최소화
}
```

---

## 통합 예제

```java
// 1) 상속 + super + instanceof
class Programmer {
    String language; int age;
    Programmer(String language, int age){ this.language=language; this.age=age; }
    void work(){ System.out.println("일합니다"); }
}
class JavaProgrammer extends Programmer {
    JavaProgrammer(int age){ super("자바", age); }
}
class JavaFullStack extends JavaProgrammer {
    String frontEnd;
    JavaFullStack(int age, String frontEnd){ super(age); this.frontEnd=frontEnd; }
}

Programmer p1 = new Programmer("자바", 33);
Programmer p2 = new JavaProgrammer(44);
Programmer p3 = new JavaFullStack(55, "React");
for (Programmer p : new Programmer[]{p1,p2,p3}) p.work();
if (p3 instanceof JavaFullStack) System.out.println("p3은 자바풀스택!");

// 2) 바인딩(필드 vs 메서드) + 오버로딩/오버라이딩
class Car {
    int price = 10000;                 // 정적 바인딩 대상(필드)
    void trigger(){ System.out.println("시동 걸림"); }
    void hello(){ System.out.println("Car:"+price); }
    void hello2(){ System.out.println("Car:"+price); }
}
class RacingCar extends Car {
    int price = 50000;                 // 필드 은닉
    String color = "red";             // 예시 필드
    String getColor(){ return color; }
    @Override void trigger(){ super.trigger(); System.out.println("레이싱카라 좀 더 빨리 걸림"); }
    @Override void hello2(){ System.out.println("Racing:"+price); }
    void hello(){ System.out.println("Racing:"+price); } // 오버라이딩 아님(시그니처 동일, 내용만 변경)
    void trigger(int speed){ System.out.println(speed+"로 출발 준비"); } // 오버로딩
}

Car c1 = new Car();
RacingCar c2 = new RacingCar();
Car c3 = new RacingCar();             // 업캐스팅
System.out.println(c1.price);          // 10000 (정적 바인딩)
System.out.println(c2.price);          // 50000
System.out.println(c3.price);          // 10000 (정적: 선언 타입 Car)
c3.hello(); c3.hello2();               // 동적: RacingCar 메서드 실행
c2.trigger(); c2.trigger(100);
System.out.println("Color:"+c3.getColor());

// 3) 추상 클래스 + 다형성
abstract class Worker { abstract void work(); void run(){ System.out.println("뛴다!"); } }
class FarmWorker extends Worker { @Override void work(){ System.out.println("농장 좋아!"); } }
class SeaWorker  extends Worker { @Override void work(){ System.out.println("바다 좋아!"); } }
for (Worker w : new Worker[]{ new FarmWorker(), new SeaWorker() }) { w.work(); }

// 4) 인터페이스 + 다중 구현 + instanceof 패턴 매칭
interface Runnable { void run(); default void runToYou(){ System.out.println("무언가..."); } }
interface Talkable { void talk(); }
interface Cute { void doCute(); }
class Dog implements Runnable, Cute {
    public void run(){ System.out.println("개가 뛴다"); }
    public void doCute(){ System.out.println("개는 귀엽다"); }
}
class Human implements Runnable, Talkable {
    public void run(){ System.out.println("사람이 뛴다"); }
    public void talk(){ System.out.println("사람은 말한다"); }
}

for (Runnable r : new Runnable[]{ new Dog(), new Human() }) {
    r.run();
    if (r instanceof Cute c) c.doCute();
    else if (r instanceof Talkable t) t.talk();
}
```
