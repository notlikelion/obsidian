# 01. 클래스, 객체, 메서드

#java #oop #클래스 #class #클래스 #객체 #object #오브젝트 #메서드 #method

---

https://github.com/notlikelion/250804_oop/tree/main/src/step1

## 접근 제어자 (Access Modifiers)

#접근제어자 #access-modifiers #캡슐화 #encapsulation

- 실생활 비유: 집 문 단속처럼, 어디까지 공개할지 문을 여닫아 내부를 보호합니다.
- CS 관점: 정보 은닉으로 결합도를 낮추고 변경의 파급 효과를 최소화합니다.

| 키워드      | 가시 범위                     | 클래스 선언           | 특징                                       |
| ----------- | ----------------------------- | --------------------- | ------------------------------------------ |
| `public`    | 모든 곳                       | O                     | 완전 공개 (패키지·모듈 경계 무시)          |
| _(default)_ | 동일 _패키지_                 | O                     | 키워드 생략 시 적용, 외부 패키지 접근 불가 |
| `protected` | 동일 패키지 + **하위 클래스** | X                     | 서브클래스에만 추가 공개                   |
| `private`   | 동일 _클래스_                 | X (중첩 클래스에는 O) | 완전 은닉; 캡슐화 핵심                     |

```java
class Member {
    private int age = 30;                // 외부에서 직접 접근 불가
    protected String nickname = "cat";   // 패키지 + 하위 클래스에서 접근
    public void setAge(int age){ this.age = age; } // 공개는 메서드를 통해 최소화
}
```

**요약** : 캡슐화를 통해 _불변성·보안성_ 강화 → 외부 노출 최소화

---

## 클래스와 객체 (Class & Object)

#클래스 #class #클래스 #객체 #object #오브젝트

- 실생활 비유: 클래스는 ‘설계도’, 객체는 그로부터 만들어진 ‘제품’입니다.
- CS 관점: 상태(필드)와 행동(메서드)을 묶어 응집도를 높이고 재사용성을 확보합니다.

```java
class Bicycle {
    int gear;                          // 상태
    void changeGear(int g){ gear = g; } // 행동
}

Bicycle road = new Bicycle();   // 객체 생성
road.changeGear(3);
```

---

## 생성자 (Constructors)

#생성자 #constructor #컨스트럭터

- 실생활 비유: 새 제품을 출고하기 전 기본 세팅을 하는 단계입니다.
- CS 관점: 객체를 ‘유효한 상태’로 초기화하며, 오버로딩으로 다양한 생성 경로를 제공합니다.

### 특징

- 클래스명과 동일, **반환 타입 없음**
- 객체 초기화를 담당하며, `abstract` / `static` / `final` 불가
- 명시하지 않으면 컴파일러가 **기본(no‑arg) 생성자**를 추가

### 종류 & 예시

```java
class User {
    String id;
    User(){ this("guest"); }        // 기본값으로 위임
    User(String id){ this.id = id; }  // 전달받은 값으로 초기화
}
```

### 생성자 오버로딩

매개변수 시그니처를 달리하여 여러 생성자 제공 → 가독성·유연성 ↑.

---

## 메서드 (Methods)

#메서드 #method #메써드 #반환타입 #return-type #리턴-타입

- 실생활 비유: 기계의 버튼들(기능)과 출력물이 메서드 정의/반환값에 해당합니다.
- CS 관점: 인터페이스(시그니처)로 계약을 정의하고 구현으로 행위를 제공합니다.

### 선언 형식

```java
[modifier] [static] returnType name(paramList) { ... }
```

- `static` : 클래스 소속(객체 불필요)
- `void` : 반환값 없음

### 호출

```java
class Calc {
    static int add(int a, int b){ return a + b; }
    int sub(int a, int b){ return a - b; }
}

int s = Calc.add(3,5);   // static 메서드 호출
Calc c = new Calc();
int d = c.sub(7,2);      // 인스턴스 메서드 호출
```

### 매개변수 & 반환

- **형식 인수(Formal)** ⇆ **실제 인수(Actual)** 타입 일치 필수
- `return` 으로 값 전달; `void` 이면 생략 가능

---

## 메서드 오버로딩 (Method Overloading)

#오버로딩 #overloading #오버로우딩

- 실생활 비유: 같은 버튼 이름이더라도 입력되는 물건의 ‘종류/개수’에 따라 동작이 달라집니다.
- CS 관점: 동일 이름-다른 시그니처로 사용성 향상. 반환 타입만 바꿔서는 구분되지 않습니다.

```java
void log(String msg) {}
void log(String msg, int level) {}
void log(int code) {}
```

→ 호출 시 컴파일러가 시그니처로 구분.

---

## `static` 키워드

#static #정적 #스태틱 #공유상태

- 실생활 비유: 모든 지점이 함께 쓰는 ‘공용 창고’와 같습니다.
- CS 관점: 클래스 레벨 공유 상태/기능 제공. 남용 시 테스트 어려움과 결합도 증가에 주의.

| 요소                   | 설명 & 예시                               |
| ---------------------- | ----------------------------------------- |
| **static 변수**        | 모든 객체가 **공유**. `static int count;` |
| **static 메서드**      | 객체 없이 호출. `Math.sqrt(4)`            |
| **static 블록**        | 클래스 로드 시 1회 실행. `static { ... }` |
| **중첩 static 클래스** | 외부 클래스 생성 없이 사용 가능           |

```java
class Config {
    static final String VERSION = "1.0"; // 상수
    static { System.out.println("Config loaded"); }
}
```

---

## `String`

#문자열 #string #스트링 #불변 #immutable

- 실생활 비유: 펜으로 쓴 글은 지우개가 아니라 ‘다시 쓰기(새 종이)’로 바뀌는 것과 유사합니다.
- CS 관점: 불변이라 스레드 안전성과 캐싱에 유리. 잦은 결합은 `StringBuilder` 고려.

- **생성 방식**
  - 리터럴 → JVM String Pool 재사용
  - `new String()` → 매번 새 객체

```java
String a = "Java";
String b = new String("Java"); // a ≠ b (참조 다름)
```

- **주요 연산**
  - 길이 : `a.length()`
  - 결합 : `a + "17"` 또는 `a.concat("17")`
  - 비교 : `a.equals(b)`(내용), `==`(참조)

---

## `final` 키워드

#final #파이널 #상수 #constant #불변성

- 실생활 비유: ‘봉인 스티커’가 붙어 더 이상 바꿀 수 없는 상태.
- CS 관점: 재할당/상속/오버라이딩 제약으로 설계 안정성과 최적화 이점.

| 대상   | 제약            | 효과             |
| ------ | --------------- | ---------------- |
| 변수   | 재할당 불가     | 상수화 (_const_) |
| 메서드 | 오버라이드 금지 | 행위 고정        |
| 클래스 | 상속 금지       | 확장 차단        |

```java
final class Util {}
final int MAX = 100;
```

---

## `instanceof` 연산자

#instanceof #타입체크 #타입체킹

- 실생활 비유: 입장 시 신분증 검사로 ‘어떤 종류’인지 확인합니다.
- CS 관점: 런타임 타입 점검 후 안전한 캐스팅에 활용.

```java
Animal a = new Dog();
if (a instanceof Dog) { ((Dog)a).bark(); }
```

---

## `this` 키워드

#this #디스 #현재객체 #current-object

- 실생활 비유: “나 자신”을 가리키는 지시어입니다.
- CS 관점: 필드/매개변수 충돌 해소, 생성자 체이닝, 자기 참조 전달에 사용.

```java
class Point {
    int x, y;
    Point(int x,int y){ this.x = x; this.y = y; }
    Point(){ this(0,0); }
}
```

---

## 패키지와 임포트

#패키지 #package #임포트 #import #네임스페이스 #namespace

- 실생활 비유: 우편물의 주소 체계와 같습니다. 정확한 배달을 위해 필요합니다.
- CS 관점: 클래스 네임스페이스 제공으로 이름 충돌 방지 및 조직적 구조를 지원합니다.

```java
package step1; // 패키지 선언

import ex.Student; // 외부 클래스 임포트

public class Solution {
    public static void main(String[] args) {
        Student s = new Student(); // 임포트 후 사용 가능
    }
}
```
